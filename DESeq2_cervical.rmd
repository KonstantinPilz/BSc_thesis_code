---
title: "DESeq2_cervical
output: html_DESeq2_cervical
---
https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html
This is the analysis of the cervical data set provided by the authors of MLSeq using DESeq2.



1. load libraries

```{r}
## ----setup, echo=FALSE, results="hide"----------------------------------------
knitr::opts_chunk$set(tidy = FALSE,
                      cache = FALSE,
                      dev = "png",
                      message = FALSE, error = FALSE, warning = TRUE)
library("DESeq2")
```
2. load and read file
The cervical data set is a count matrix, to use it in DESeq2 analysis we use the method "DESeqDataSetFromMatrix" which expects the following inputs:
A) The count matrix
B) A data.frame/ DataFrame object
C) A design argument that I don't fully understand but which seems to be necessary
Since there is no data.frame object provided for the cervical data, we need to provide it. To do so, we create a table containing one column for the sample number and one column for the treatment. The first 29 samples are controls, the last 29 are treated.
```{r}
load(file="/home/pilz/data/MLSeq_original_data/cervical.rda")
#creating the data.frame object
class <- data.frame(condition = factor(rep(c("untreated","treated"), c(29, 29))))
#optional: check data.frame object and beginning of the data
class
head(cervical)
#read the data into a DESeqDataSet
dds <- DESeqDataSetFromMatrix(countData = cervical,
                              colData = class,
                              design = ~ condition)
#look at object
dds

```
3. Pre-filtering
by excluding low count genes we reduce the memory usage of the later methods
```{r}
keep <- rowSums(counts(dds)) >= 10
dds <- dds[keep,]
```
4. set factor levels
It may be important to make sure in which order the conditions are compared. (default is alphabetical order)
```{r}
dds$condition <- factor(dds$condition, levels = c("untreated","treated"))
```
5. Standard differential expression analysis
This method foes through all steps of DESeq2 and gives results.
```{r}
dds <- DESeq(dds)
res <- results(dds)
res
```
6. Perform LFC transformation
For better visualization and gene ranking we use the method lfcShrink
```{r}
resultsNames(dds)
resLFC <- lfcShrink(dds, coef="condition_treated_vs_untreated", type="apeglm")
resLFC
```
7. Table ordered by p-value
For a better overview we can order the table by p-value and give a summary of how many p-values were <0.1
Finally, we can get a results table.
```{r}
resOrdered <- res[order(res$pvalue),]
resOrdered
summary(res)
#How many below 0.1?
sum(res$padj < 0.1, na.rm=TRUE)
#results table
res05 <- results(dds, alpha=0.05)
summary(res05)
sum(res05$padj < 0.05, na.rm=TRUE)
```
After this simple analysis, we will now go on to take the steps in between individually.
8. rlog-transformation
Apparently, you do this if you don't want to do DE but visualization and clustering instead. Main point is to remove the high variance for low means
rlog ~ regularized logarithm - normalizes on basis of library size and transforms data to log2 scale
(For a big number of samples there is an alternative: VST ~  variance stabilizing transformations)
```{r}
rld <- rlog(dds, blind=FALSE)
head(assay(rld), 3)

```
9. Plot showing dependence of sd on mean
```{r}
#plot of sd and mean
library("vsn")
meanSdPlot(assay(rld))
```
This is not what I expected. The sd should be normalized -> about equal for any mean
10. Heatmap
```{r}
library("pheatmap")
select <- order(rowMeans(counts(dds,normalized=TRUE)),
                decreasing=TRUE)[1:20]
df <- as.data.frame(colData(dds)[,c("condition","type")])
pheatmap(assay(rld)[select,], cluster_rows=FALSE, show_rownames=FALSE,
         cluster_cols=FALSE, annotation_col=df)
```
